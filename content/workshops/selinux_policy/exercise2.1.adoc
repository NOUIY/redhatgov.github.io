---
title: "Exercise 2.1 - Generating a generic policy"
workshops: selinux_policy
workshop_weight: 21
layout: lab
---

:icons: font
:imagesdir: /workshops/selinux_policy/images

= Exercise 2.1 - Generating a generic policy



== Exercise Description

In this exercise, we are going to automatically generate an SELinux policy framework, and learn to handle AVC messages that are generated by SELinux, when the application violates the policy.

=== Step 1: Generate an initial generic SELinux policy

Create a policy directory, and generate an initial policy.  Use `sepolicy generate` to generate a policy for the app that we want to enable.

{{< highlight bash >}}
cd ~/src
mkdir policy
cd policy
sepolicy generate --init /usr/local/sbin/testapp
{{< /highlight >}}

Note the last few lines in the output from `sepolicy generate`:
[source,bash]
----
Created the following files:
/home/ec2-user/src/policy/testapp.te # Type Enforcement file
/home/ec2-user/src/policy/testapp.if # Interface file
/home/ec2-user/src/policy/testapp.fc # File Contexts file
/home/ec2-user/src/policy/testapp_selinux.spec # Spec file
/home/ec2-user/src/policy/testapp.sh # Setup Script
----

You will need all of these files to customize the policy for the application.

.SELinux Policy Source Compnents
. `testapp.te` is the base policy for the application.  It sets the rules for the `testapp_t` domain
. `testapp.if` is the *interface* file.  Interfaces are like public functions, in that they provide ways for other SELinux modules to interact with the one that you are writing
. `testapp.fc` is the *file contexts* file.  It contains the labeling information for all filesystem objects that the policy references
. `testapp.sh` is a Red Hat provided script that compiles and loads the SELinux policy module

=== Step 2: Compile the policy framework

Now, compile and load the SELinux policy framework, by running the `testapp.sh` script.  The script needs to be run with *root* privileges, since it changes the running SELinux configuration:

{{< highlight bash >}}
sudo ./testapp.sh
{{< /highlight >}}

The first 9 lines of the output show the policy compilation, the loading of the policy into memory, and the automatic generation of a manpage for the policy:
[source,bash]
----
Building and Loading Policy
+ make -f /usr/share/selinux/devel/Makefile testapp.pp
Compiling targeted testapp module
Creating targeted testapp.pp policy package
rm tmp/testapp.mod tmp/testapp.mod.fc
+ /usr/sbin/semodule -i testapp.pp
+ sepolicy manpage -p . -d testapp_t
./testapp_selinux.8
----

In addition to compiling and loading the policy, the `testapp.sh` script also generates an RPM spec file, and builds a package, containing the policy for the app.  This makes it easy to redistribute the policy, when you have finished creating it.  You can see this in the second part of the script output:

[source,bash]
----
+ /sbin/restorecon -F -R -v /usr/local/sbin/testapp
Relabeled /usr/local/sbin/testapp from system_u:object_r:bin_t:s0 to system_u:object_r:testapp_exec_t:s0
+ /sbin/restorecon -F -R -v /var/run/testapp.pid
Relabeled /run/testapp.pid from system_u:object_r:var_run_t:s0 to system_u:object_r:testapp_var_run_t:s0
++ pwd
+ pwd=/home/ec2-user/src/policy
+ rpmbuild --define '_sourcedir /home/ec2-user/src/policy' --define '_specdir /home/ec2-user/src/policy' --define '_builddir /home/ec2-user/src/policy' --define '_srcrpmdir /home/ec2-user/src/policy' --define '_rpmdir /home/ec2-user/src/policy' --define '_buildrootdir /home/ec2-user/src/policy/.build' -ba testapp_selinux.spec
Executing(%install): /bin/sh -e /var/tmp/rpm-tmp.apQ8LZ
+ umask 022
+ cd /home/ec2-user/src/policy
+ '[' /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el8.x86_64 '!=' / ']'
+ rm -rf /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el8.x86_64
++ dirname /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el8.x86_64
+ mkdir -p /home/ec2-user/src/policy/.build
+ mkdir /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el8.x86_64
+ install -d /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el8.x86_64/usr/share/selinux/packages
+ install -m 644 /home/ec2-user/src/policy/testapp.pp /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el8.x86_64/usr/share/selinux/packages
+ install -d /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el8.x86_64/usr/share/selinux/devel/include/contrib
+ install -m 644 /home/ec2-user/src/policy/testapp.if /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el8.x86_64/usr/share/selinux/devel/include/contrib/
+ install -d /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el8.x86_64/usr/share/man/man8/
+ install -m 644 /home/ec2-user/src/policy/testapp_selinux.8 /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el8.x86_64/usr/share/man/man8/testapp_selinux.8
+ install -d /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el8.x86_64/etc/selinux/targeted/contexts/users/
+ /usr/lib/rpm/check-buildroot
+ /usr/lib/rpm/redhat/brp-ldconfig
/sbin/ldconfig: Warning: ignoring configuration file that cannot be opened: /etc/ld.so.conf: No such file or directory
+ /usr/lib/rpm/brp-compress
+ /usr/lib/rpm/brp-strip /usr/bin/strip
+ /usr/lib/rpm/brp-strip-comment-note /usr/bin/strip /usr/bin/objdump
+ /usr/lib/rpm/brp-strip-static-archive /usr/bin/strip
+ /usr/lib/rpm/brp-python-bytecompile '' 1
+ /usr/lib/rpm/brp-python-hardlink
+ PYTHON3=/usr/libexec/platform-python
+ /usr/lib/rpm/redhat/brp-mangle-shebangs
Processing files: testapp_selinux-1.0-1.el8.noarch
Provides: testapp_selinux = 1.0-1.el8
Requires(interp): /bin/sh /bin/sh
Requires(rpmlib): rpmlib(CompressedFileNames) <= 3.0.4-1 rpmlib(FileDigests) <= 4.6.0-1 rpmlib(PayloadFilesHavePrefix) <= 4.0-1
Requires(post): /bin/sh policycoreutils selinux-policy-base >= 3.14.3-139
Requires(postun): /bin/sh policycoreutils
Checking for unpackaged file(s): /usr/lib/rpm/check-files /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el8.x86_64
Wrote: /home/ec2-user/src/policy/testapp_selinux-1.0-1.el8.src.rpm
Wrote: /home/ec2-user/src/policy/noarch/testapp_selinux-1.0-1.el8.noarch.rpm
Executing(%clean): /bin/sh -e /var/tmp/rpm-tmp.ql2Cxs
+ umask 022
+ cd /home/ec2-user/src/policy
+ /usr/bin/rm -rf /home/ec2-user/src/policy/.build/testapp_selinux-1.0-1.el8.x86_64
+ exit 0
----

=== Step 3: Check to see your policy in action

If we reload the application, the newly compiled and loaded policy module will be attached to it:

{{< highlight bash >}}
sudo systemctl stop testapp
sudo systemctl start testapp
ps -efZ | grep testapp | grep -v grep
{{< /highlight >}}

[source,bash]
----
system_u:system_r:testapp_t:s0  root      8737     1  0 20:51 ?        00:00:00 /usr/local/sbin/testapp
----

=== Step 4: How does the application end up with the *testapp_t* context?

This is because of SELinux domain transition rules.  The `testapp` service is started by `systemd`, which runs with a context of `init_t`, as it is our init service.  Because of the transition rules, it changes contexts when the service is launched. The rule says that any process labeled as `init_t` will execute any binary labeled as `testapp_exec_t`, the newly-created process will be labeled as `testapp_t`.

To see those rules, type this:
{{< highlight bash >}}
sesearch -T -s init_t -t testapp_exec_t
{{< /highlight >}}

[source,bash]
----
type_transition init_t testapp_exec_t : process testapp_t;
----

The rule says that when any process labeled as `init_t` executes any binary labeled as `testapp_exec_t`, the newly-created process will be labeled as `testapp_t`.

=== End Result

At this point, we have a generic policy for the `testapp` application, which is set for *permissive mode*. Thus, the application can run, and SELinux will generate alerts when existing system policy is violated, but will take no action.

{{< importPartial "footer/footer.html" >}}
